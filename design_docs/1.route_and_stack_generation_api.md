
# Routing API design

## Scenario

For designing the API this fairly common and complex scenario will be taken as the base case to solve:

```
  '/loading' => user access this page when the authentication state is unknown
  '/sign-in' => user access this page when unauthenticated
  '/sign-in/phone' => user can access this nested page when unauthenticated 
  '/create-profile' => when user is authenticated but doesn't have a profile 
  '/dashboard' => when the user is authenticated & has a profile, the dashboard
  '/products' => when the user is authenticated & has a profile and clicked on a menu item to see the products
  '/products/:id' => when the user wants to see a specific product
```

## Route naming convention 

From the scenario go we can notice that the up stack can be defined as a function of the url path where each segment is a screen in the stack.
For example when on the '/sign-in/phone' route the up stack will look like this:

```
  - SignInScreen
  - SignInWithPhoneScreen
```

On the product details page the up stack will look like this

```
  - ProductsScreen
  - ProductDetailsScreen
```

The only question mark is what happens with the path '/' that we will call home route.


## Home route

Websites are firstly accessed by their main url, eg: www.facebook.com. That main url we define it as `home route` or '/' for short.

The problem with the home route is that the material specs aren't realistic as a webapp standpoint in our scenario. The material specs specify that the home must be the upper most activity in the up stack. Thaht doesn't play well with /sign-in page.

2 question marks remain for that home route:

  - Should the home route be part of the stack when navigating to '/products'
  - What happens when the user types the home route in our scenario since we didn't define it

The two question are intertwined depending on how we approach it:
  1. Either the user is redirected to another page, eg: /dashboard in which case 
    the home route is only part of the stack when we are on /dashboard
  2. Either '/' is not redirected, always defined and always part of the stack in which case
    we have to define what happens when we go to /sign-in
  3. Either '/' must be defined and only sometimes part of the stack, which makes it tricky both as an API and as implementation
  4. Either '/' must be defined and never part of the stack


1 can be picked as a default scenario by introducing the parameter home:
```
  home: '/dashboard'
```
3. is too complex

For 1 & 4 they could as well be in the spec but it's not clear which one should be favorited. While The material design specs says the home route should be the top most page of every application, it doesn't fit the narative of an app having a /sign-in route

## Option design 1 : Strict routing naming conventions

```
Router(
  home: '/dashboard', 
  routes: {
    '/sign-in': (context, params) => SignInPage(),
    '/sign-in/phone': (context, params) => SignInWithPhonePage(),
    '/create-profile': (context, params) => CreateProfilePage(),
    '/dashboard': (context, params) => Dashboard(),
    '/products': (context, params) => ProductsPage(),
    '/products/:id': (context, params) => ProductDetailsPage(params['id']),
  },

)
```

In this scenario the routing mechanism obey strict conventions of the url to manage the stack. As discussed before.

```
'/': redirect on /dashboard
'/sign-in/phone': has SignInScreen and SignInWithPhoneScreen in the stack
'/dashboard': has dashboard in the stack
'/products/:id': has ProductDetailScreen and ProductsScreen in the stack
```

If the user wants the home to be the top most Screen in the up stack of products, the user can change the routing as such:

```
Router(
  home: '/app',
  routes: {
    '/sign-in': (context, params) => SignInPage(),
    '/sign-in/phone': (context, params) => SignInWithPhonePage(),
    '/create-profile': (context, params) => CreateProfilePage(),
    '/app': (context, params) => HomePage(),
    '/app/products': (context, params) => ProductsPage(),
    '/app/products/:id': (context, params) => ProductDetailsPage(params['id']),
  }
)
```

*Drawbacks*: 
  - url might not be exactly to user preferences 

## Option design 2 : Nesting

```
Router(
  home: '/app',
  routes: [
    RouteConfig(
      path: '/sign-in',
      builder: (context, params) => SignInPage(),
      children: [
        RouteConfig( 
          path: '/phone', 
          builder: (context, params) => SignInWithPhonePage()
        )
      ]
    ),
    //...
  }
)
```

We can see that if the route naming convention has to be respected here too, it doesn't offer any advantage in readability. We have to check the parent to see the whole path

*Drawbacks*:
  - Less readability
  - harder to implement as we have to check parents (tree) instead of just checking the segments of a path.


## Option design 3: pattern matching


```
Router(
  home: '/dashboard',
  routes: {
    '/sign-in': (context, params) => SignInPage(),
    '/sign-in/**': (context, params) => SignInPage(),
    '/sign-in/phone': (context, params) => SignInWithPhonePage(),
    '/create-profile': (context, params) => CreateProfilePage(),
    '/dashboard': (context, params) => DashBoardPage(),
    '/products': (context, params) => ProductsPage(),
    '/products/**': (context, params) => ProductsPage(),
    '/products/:id': (context, params) => ProductDetailsPage(params['id']),
  }
)
```

Here we have repetition but we could make a rule that ** allow the current directory as well or add another wildcard

```
Router(
  home: '/dashboard',
  routes: {
    '/sign-in/?': (context, params) => SignInPage(),
    '/sign-in/phone': (context, params) => SignInWithPhonePage(),
    '/create-profile': (context, params) => CreateProfilePage(),
    '/dashboard': (context, params) => DashboardPage(),
    '/products/?': (context, params) => ProductsPage(),
    '/products/:id': (context, params) => ProductDetailsPage(params['id']),
  }
)
```


*advantages* :
  - the user has more control over the stack
*drawbacks* :
  - user has to learn a pattern


## Option design 4 Add stack properties to the routes 

```
Router(
  home: '/dashboard',
  routes: [
    Route(
      path: '/sign-in/', 
      builder: (context, params) => SignInPage(),
    ),
    Route(
      path: '/sign-in/phone', 
      builder: (context, params) => SignInWithPhonePage(),
      upstack: ['/sign-in'] 
    ),
  ]
)
```

 - Although a bit less consise, having a route class would make typing easier for future version.
 - It remains to be defined if custom stacks in this scenario would be useful.

A possible scenario would be: 
We could have /forms/:formId/submit-status and want an up buttons that lets the user go back to the list of forms but not modify the form he already submitted. The stack would look like ['forms'] (+ current route).


## Conclusions

While scenario 1 is really easy to setup, scenario 3 offers a bit more control as well as scenario 4. Scenario 4 introduce Route class that would make it more future proof.

Route can be kept for future proofing. The final scenario below will be implemented. Then if the need is apparent, the stack property will be added.


```
Router(
  home: '/dashboard',
  routes: [
    Route(
      path: '/sign-in', 
      builder: (context, params) => SignInPage(),
    ),
    Route(
      path: '/sign-in/phone', 
      builder: (context, params) => SignInWithPhonePage(),
    ),
    // ...
  ]
)
```

